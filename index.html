<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fight Me</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Next:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Atkinson Hyperlegible Next"', 'sans-serif'],
                    },
                },
            }
        }
    </script>
    
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <style>
        :root {
            --background-color: #0c1a2c; /* Dark Blue/Slate */
            --surface-color: #1a2a3c;   /* Slightly lighter surface */
            --accent-color: #f59e0b;      /* Amber */
            --text-color: #ffffffde;
            --work-color: #f59e0b;      
            --rest-color: #10b981;      
            --warn-color: #fcd34d;      
        }
        body {
            font-family: 'Atkinson Hyperlegible Next', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        #timer-display {
            font-size: clamp(3.5rem, 18vw, 9rem); 
            line-height: 1;
            font-weight: 900;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2); 
            transition: text-shadow 0.5s ease, color 0.5s ease;
            text-align: center;
            letter-spacing: -0.05em;
        }
        /* Custom scrollbar for better look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--surface-color); }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }

        /* Style the select dropdown */
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25rem 1.25rem;
        }
        
        /* Volume Slider Customization */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            margin-top: -5px; 
            box-shadow: 0 0 5px rgba(245, 158, 11, 0.6);
            transition: background 0.2s;
        }
        input[type=range]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--accent-color);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 0 5px rgba(245, 158, 11, 0.6);
            transition: background 0.2s;
        }
        input[type=range]::-webkit-slider-runnable-track {
            height: 4px;
            background: #475569;
            border-radius: 2px;
        }
        input[type=range]::-moz-range-track {
            height: 4px;
            background: #475569;
            border-radius: 2px;
        }

        /* Confetti Container Styling */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 60;
        }

        /* Basic Confetti Particle Style (CSS only for simplicity) */
        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--accent-color);
            opacity: 0;
            animation: pop 2.5s ease-out forwards;
        }

        @keyframes pop {
            0% { transform: translateY(0) rotate(0deg); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0.5; }
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 font-sans">

    <div id="confetti-container"></div>
    
    <div id="app" class="w-full max-w-sm sm:max-w-2xl bg-[--surface-color] shadow-2xl rounded-2xl p-6 sm:p-8 space-y-6 border border-slate-700">
        
        <header class="text-center flex justify-between items-center">
            <div class="w-1/5"></div> <div class="flex-grow">
                <h1 class="text-3xl sm:text-4xl font-extrabold text-white tracking-wide">Fight Me</h1>
                <p id="workout-name" class="text-lg sm:text-xl text-slate-400 mt-1">A boxing training app</p>
            </div>
            <div class="w-1/5 flex justify-end">
                <button id="fullscreen-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen"
                    class="p-2.5 bg-slate-700 hover:bg-slate-600 rounded-full text-white transition duration-150 active:scale-95">
                    <i data-lucide="maximize" class="w-6 h-6" id="fullscreen-icon"></i>
                </button>
            </div>
        </header>

        <div id="combo-callout" class="text-center text-2xl sm:text-3xl text-amber-500 font-extrabold min-h-[50px] p-3 bg-slate-700/50 rounded-lg shadow-inner flex items-center justify-center">
            <span class="text-slate-400 text-base">Press Start to begin training!</span>
        </div>

        <div class="text-center py-2 space-y-2">
            <div id="total-time-display" class="text-lg text-slate-400 font-semibold tabular-nums">
                Total Remaining: 00:00
            </div>
            <div id="timer-display" class="font-extrabold text-white tracking-tighter tabular-nums transition-colors duration-500">
                03:00
            </div>
        </div>

        <div class="space-y-6 max-h-[60vh] overflow-y-auto">
            <div id="config-card" class="bg-slate-700 rounded-xl p-4 sm:p-6 space-y-6 shadow-xl opacity-100 transition-opacity duration-300">
                
                <div class="space-y-3 border-b border-slate-600 pb-4">
                    <h3 class="text-xl font-bold text-amber-400">Timer Settings</h3>
                    <div class="grid grid-cols-3 gap-3 sm:gap-4">
                        <div class="space-y-1">
                            <label for="round-duration" class="text-xs font-semibold text-slate-300 block">Round Mins</label>
                            <input type="number" id="round-duration" value="3" min="1" oninput="updateConfig()"
                                class="w-full bg-slate-800 text-white p-2 rounded-lg border-2 border-slate-600 focus:border-amber-500 transition duration-150 text-center">
                        </div>
                        <div class="space-y-1">
                            <label for="rest-duration" class="text-xs font-semibold text-slate-300 block">Rest Mins</label>
                            <input type="number" id="rest-duration" value="1" min="0" oninput="updateConfig()"
                                class="w-full bg-slate-800 text-white p-2 rounded-lg border-2 border-slate-600 focus:border-amber-500 transition duration-150 text-center">
                        </div>
                        <div class="space-y-1">
                            <label for="num-rounds" class="text-xs font-semibold text-slate-300 block">Total Rounds</label>
                            <input type="number" id="num-rounds" value="5" min="1" oninput="updateConfig()"
                                class="w-full bg-slate-800 text-white p-2 rounded-lg border-2 border-slate-600 focus:border-amber-500 transition duration-150 text-center">
                        </div>
                    </div>
                </div>

                <div class="space-y-4">
                    <h3 class="text-xl font-bold text-amber-400">Combo Logic Settings</h3>

                    <div class="space-y-2">
                        <label for="combo-length" class="text-sm font-semibold text-slate-300 block">1. Combo Length <span id="length-label" class="text-amber-300 ml-2 text-xs font-normal">Medium (1-4 Punches)</span></label>
                        <input type="range" id="combo-length-slider" min="0" max="2" value="1" step="1" oninput="updateConfig()"
                            class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-amber-500">
                        <div class="flex justify-between text-xs text-slate-400 pt-1">
                            <span>Low</span><span>Medium</span><span>High</span>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <label for="combo-difficulty" class="text-sm font-semibold text-slate-300 block">2. Combo Difficulty <span id="difficulty-label" class="text-amber-300 ml-2 text-xs font-normal">Medium (Some Same-Side)</span></label>
                        <input type="range" id="combo-difficulty-slider" min="0" max="2" value="1" step="1" oninput="updateConfig()"
                            class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-amber-500">
                        <div class="flex justify-between text-xs text-slate-400 pt-1">
                            <span>Low</span><span>Medium</span><span>High</span>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <label for="move-complexity" class="text-sm font-semibold text-slate-300 block">3. Move Complexity <span id="complexity-label" class="text-amber-300 ml-2 text-xs font-normal">Medium (Occasional Non-Punches)</span></label>
                        <input type="range" id="move-complexity-slider" min="0" max="2" value="1" step="1" oninput="updateConfig()"
                            class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-amber-500">
                        <div class="flex justify-between text-xs text-slate-400 pt-1">
                            <span>Low</span><span>Medium</span><span>High</span>
                        </div>
                    </div>
                </div>

                <div class="space-y-4 border-t border-slate-600 pt-4">
                    <h3 class="text-xl font-bold text-amber-400">Audio & Control Settings</h3>
                    
                    <div class="grid grid-cols-2 gap-4"> 
                        <div class="space-y-1">
                            <label for="combo-repetitions-select" class="text-xs font-semibold text-slate-300 block">4. Combo Intensity</label>
                            <select id="combo-repetitions-select" onchange="updateConfig()"
                                class="w-full bg-slate-800 text-white p-2 rounded-lg border-2 border-slate-600 focus:border-amber-500 transition duration-150 appearance-none pr-10">
                                <option value="1">Low (1x Repetition)</option>
                                <option value="2">Medium (2x Repetitions)</option>
                                <option value="3" selected>High (3x Repetitions)</option>
                            </select>
                        </div>

                        <div class="space-y-1">
                            <label for="voice-volume-slider" class="text-xs font-semibold text-slate-300 block">5. Voice Volume (<span id="voice-volume-label">100%</span>)</label>
                            <input type="range" id="voice-volume-slider" min="0" max="1" step="0.05" value="1" oninput="updateVoiceVolume()"
                                class="w-full h-2 bg-slate-800 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-amber-500">
                        </div>
                    </div> 
                    <div id="controls" class="flex flex-col space-y-3 pt-2">
                        <button id="start-btn" onclick="startTimer()" 
                            class="w-full p-4 bg-amber-500 hover:bg-amber-600 text-slate-900 text-xl font-bold rounded-xl shadow-lg transition duration-150 active:scale-95 flex items-center justify-center space-x-2">
                            <i data-lucide="play" class="w-6 h-6"></i>
                            <span>START ROUNDS</span>
                        </button>
                        <div class="flex space-x-3">
                            <button id="pause-btn" onclick="pauseTimer()" disabled 
                                class="flex-grow p-3 bg-slate-600 hover:bg-slate-500 text-white font-semibold rounded-xl transition duration-150 active:scale-95 opacity-50 cursor-not-allowed flex items-center justify-center space-x-2">
                                <i data-lucide="pause" class="w-5 h-5"></i>
                                <span>Pause</span>
                            </button>
                            <button id="reset-btn" onclick="resetTimer()" 
                                class="flex-grow p-3 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-xl transition duration-150 active:scale-95 flex items-center justify-center space-x-2">
                                <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
                                <span>Reset</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="info-card" class="bg-slate-700 rounded-xl p-4 sm:p-6 space-y-4 shadow-xl opacity-0 transition-opacity duration-300 pointer-events-none absolute inset-0 sm:relative sm:inset-auto sm:pointer-events-auto">
                
                <div class="flex justify-between items-center pb-2 border-b border-slate-600">
                    <div class="text-xl font-bold text-white">Round Progress</div>
                    <div class="text-lg font-semibold text-amber-300">Round <span id="current-round">1</span> / <span id="total-rounds">5</span></div>
                </div>
                <div class="grid grid-cols-2 gap-4 text-center">
                    <div class="p-4 bg-slate-800 rounded-lg">
                        <div class="text-xs font-semibold text-slate-400 uppercase">Phase</div>
                        <div id="phase-display" class="text-2xl font-extrabold text-amber-400 mt-1">Work</div>
                    </div>
                    <div class="p-4 bg-slate-800 rounded-lg">
                        <div class="text-xs font-semibold text-slate-400 uppercase">Next Callout In</div>
                        <div id="combo-countdown" class="text-2xl font-extrabold text-white mt-1 tabular-nums">0s</div>
                    </div>
                </div>

                <div class="pt-2 border-t border-slate-600">
                    <h4 class="text-lg font-bold text-slate-300 mb-2">Last Callout:</h4>
                    <p id="last-combo-display" class="text-base text-slate-400 font-mono italic">--</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state and configuration
        const config = {
            roundDuration: 3,       // in minutes
            restDuration: 1,        // in minutes
            numRounds: 5,           // total rounds
            comboLength: 2,         // 0: low (1-3), 1: medium (1-4), 2: high (1-5)
            comboDifficulty: 1,     // 0: low (always alternate), 1: medium (some same-side), 2: high (frequent same-side)
            moveComplexity: 1,      // 0: low (only punches), 1: medium (occasional non-punches), 2: high (frequent non-punches)
            comboRepetitions: 3,    // 1, 2, or 3 times the combo is repeated
            voicePreference: 'Google', // Preferred voice name fragment
            voiceVolume: 1,         // 0 to 1
            
            timerRunning: false,
            roundRemaining: 0,      // in seconds
            totalElapsed: 0,        // total seconds elapsed
            currentRound: 1,        // current round number
            currentPhase: 'setup',  // 'setup', 'work', 'rest', 'finished'
            comboTime: 4000,        // interval for combo generation in ms
            comboIntervalMin: 1000, // Min time to next combo (1 second)
            
            // UI References
            timerDisplay: document.getElementById('timer-display'),
            phaseDisplay: document.getElementById('phase-display'),
            comboCallout: document.getElementById('combo-callout'),
            lastComboDisplay: document.getElementById('last-combo-display'),
            controls: document.getElementById('controls'),
            startBtn: document.getElementById('start-btn'),
            pauseBtn: document.getElementById('pause-btn'),
            resetBtn: document.getElementById('reset-btn'),
            configCard: document.getElementById('config-card'),
            infoCard: document.getElementById('info-card'),
        };

        // NEW VOICE GLOBAL STATE
        let selectedVoice = null;
        let voicesLoaded = false;
        
        // Timer intervals and timeouts
        let timerInterval = null;
        let comboInterval = null;
        let warningTimeout = null;

        // Punch Mapping
        const punchMoves = {
            // Jabs/Crosses
            '1': { call: 'one', side: 'lead', type: 'punch' }, // Jab
            '2': { call: 'two', side: 'rear', type: 'punch' }, // Cross
            // Hooks/Uppercuts
            '3': { call: 'three', side: 'lead', type: 'punch' }, // Lead Hook
            '4': { call: 'four', side: 'rear', type: 'punch' }, // Rear Hook
            '5': { call: 'five', side: 'lead', type: 'punch' }, // Lead Uppercut
            '6': { call: 'six', side: 'rear', type: 'punch' }, // Rear Uppercut
            // Body Shots (optional)
            // '1b': { call: 'one body', side: 'lead', type: 'punch' },
            // '2b': { call: 'two body', side: 'rear', type: 'punch' },
            // Movement/Defense
            'D': { call: 'slip', side: 'lead', type: 'non-punch' }, // Duck/Slip lead
            'DD': { call: 'roll', side: 'rear', type: 'non-punch' }, // Duck/Roll rear
            'L': { call: 'lead leg kick', side: 'lead', type: 'non-punch' }, // Kick Lead
            'R': { call: 'rear leg kick', side: 'rear', type: 'non-punch' }, // Kick Rear
            'P': { call: 'switch', side: 'lead', type: 'non-punch' }, // Switch Stance/Pivot
            'B': { call: 'feint', side: 'lead', type: 'non-punch' }, // Block/Feint
        };

        // Arrays for random selection
        const allPunches = ['1', '2', '3', '4', '5', '6'];
        const nonPunchMoves = ['D', 'DD', 'L', 'R', 'P', 'B']; // Keep these in if complexity is medium/high

        // Variables for state tracking in combo generation
        let lastComboMove = null;
        let lastComboLength = 0;
        let lastMoveSide = null;

        // Tone.js setup
        let workBeep;
        let restBeep;
        let finalBeep;

        try {
            workBeep = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 2,
                envelope: {
                    attack: 0.0006,
                    decay: 0.5,
                    sustain: 0.0,
                },
            }).toDestination();

            restBeep = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 2,
                envelope: {
                    attack: 0.0006,
                    decay: 0.5,
                    sustain: 0.0,
                },
            }).toDestination();

            finalBeep = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 2,
                envelope: {
                    attack: 0.0006,
                    decay: 0.5,
                    sustain: 0.0,
                },
            }).toDestination();
            
            // Initial volume settings
            workBeep.volume.value = -12;
            restBeep.volume.value = -12;
            finalBeep.volume.value = -10;
        } catch (e) {
            console.error("Tone.js initialization failed. Audio will be disabled.", e);
        }

        // --- Utility Functions ---

        /**
         * Converts total seconds to M:SS format.
         * @param {number} totalSeconds - The time in seconds.
         * @returns {string} The formatted time string.
         */
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const paddedSeconds = seconds < 10 ? '0' + seconds : seconds;
            const paddedMinutes = minutes < 10 ? '0' + minutes : minutes;
            return `${paddedMinutes}:${paddedSeconds}`;
        }

        /**
         * Updates the UI elements based on the current configuration and state.
         */
        function updateUI() {
            // Timer & Phase Display
            config.timerDisplay.textContent = formatTime(config.roundRemaining);
            config.phaseDisplay.textContent = config.currentPhase.charAt(0).toUpperCase() + config.currentPhase.slice(1);
            document.getElementById('current-round').textContent = config.currentRound;
            document.getElementById('total-rounds').textContent = config.numRounds;

            // Total Time Remaining
            const totalRemainingSeconds = (config.numRounds - config.currentRound) * (config.roundDuration * 60 + config.restDuration * 60) + config.roundRemaining;
            document.getElementById('total-time-display').textContent = `Total Remaining: ${formatTime(totalRemainingSeconds)}`;

            // Colors
            if (config.currentPhase === 'work') {
                document.body.style.backgroundColor = 'var(--work-color)';
                config.timerDisplay.style.color = 'var(--background-color)';
            } else if (config.currentPhase === 'rest') {
                document.body.style.backgroundColor = 'var(--rest-color)';
                config.timerDisplay.style.color = 'var(--background-color)';
            } else if (config.currentPhase === 'setup' || config.currentPhase === 'finished') {
                document.body.style.backgroundColor = 'var(--background-color)';
                config.timerDisplay.style.color = 'white';
            }

            // Button/Control State
            const isFinished = config.currentPhase === 'finished';
            const isRunning = config.timerRunning;

            config.startBtn.disabled = isRunning || isFinished;
            config.pauseBtn.disabled = !isRunning || isFinished;
            config.resetBtn.disabled = isFinished && config.currentPhase !== 'setup';

            config.startBtn.querySelector('span').textContent = isRunning ? 'RUNNING' : (isFinished ? 'FINISHED' : 'START ROUNDS');
            config.startBtn.classList.toggle('bg-gray-500', isRunning || isFinished);
            config.startBtn.classList.toggle('bg-amber-500', !isRunning && !isFinished);
            config.startBtn.classList.toggle('bg-green-500', isFinished); // Green finish button is nice

            config.pauseBtn.classList.toggle('opacity-100', isRunning);
            config.pauseBtn.classList.toggle('opacity-50', !isRunning);
            config.pauseBtn.classList.toggle('cursor-pointer', isRunning);
            config.pauseBtn.classList.toggle('cursor-not-allowed', !isRunning);

            // Visibility of Cards
            config.configCard.classList.toggle('opacity-100', !isRunning && !isFinished);
            config.configCard.classList.toggle('pointer-events-auto', !isRunning && !isFinished);
            
            config.infoCard.classList.toggle('opacity-100', isRunning || isFinished);
            config.infoCard.classList.toggle('pointer-events-auto', isRunning || isFinished);
        }

        /**
         * Updates the global config object from the UI inputs and applies slider labels.
         */
        function updateConfig() {
            // Timer Settings
            config.roundDuration = parseInt(document.getElementById('round-duration').value) || 3;
            config.restDuration = parseInt(document.getElementById('rest-duration').value) || 1;
            config.numRounds = parseInt(document.getElementById('num-rounds').value) || 5;
            
            // Combo Logic Settings
            config.comboLength = parseInt(document.getElementById('combo-length-slider').value) || 1;
            config.comboDifficulty = parseInt(document.getElementById('combo-difficulty-slider').value) || 1;
            config.moveComplexity = parseInt(document.getElementById('move-complexity-slider').value) || 1;

            // Audio & Control Settings
            config.comboRepetitions = parseInt(document.getElementById('combo-repetitions-select').value) || 3;
            config.voiceVolume = parseFloat(document.getElementById('voice-volume-slider').value) || 1;
            
            // Apply Labels
            const lengthLabels = ['Short (1-2 Punches)', 'Medium (1-4 Punches)', 'Long (1-6 Punches)'];
            document.getElementById('length-label').textContent = lengthLabels[config.comboLength];
            
            const difficultyLabels = ['Strict (Always Alternate)', 'Standard (Some Same-Side)', 'Complex (Frequent Same-Side)'];
            document.getElementById('difficulty-label').textContent = difficultyLabels[config.comboDifficulty];

            const complexityLabels = ['Basic (Punches Only)', 'Intermediate (Occasional Non-Punches)', 'Advanced (Frequent Non-Punches)'];
            document.getElementById('complexity-label').textContent = complexityLabels[config.moveComplexity];

            // Reset Round Time if not running to reflect new duration
            if (config.currentPhase === 'setup' || config.currentPhase === 'finished') {
                config.roundRemaining = config.roundDuration * 60;
                config.timerDisplay.textContent = formatTime(config.roundRemaining);
                document.getElementById('total-rounds').textContent = config.numRounds;
                updateUI();
            }
        }

        function updateVoiceVolume() {
            const volume = parseFloat(document.getElementById('voice-volume-slider').value);
            config.voiceVolume = volume;
            document.getElementById('voice-volume-label').textContent = `${Math.round(volume * 100)}%`;
        }

        // --- Audio Functions ---
        
        // Global variable to hold the selected voice
        
        // Function to find a preferred voice and set up the voicesLoaded flag
        function getVoice(voiceNamePreference) {
            // Only set up the event listener once and if voices are not already loaded
            if (!voicesLoaded && 'speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => {
                    const voices = window.speechSynthesis.getVoices();
                    selectedVoice = voices.find(v => v.name.includes(voiceNamePreference) && v.lang.startsWith('en')) 
                                    || voices.find(v => v.lang.startsWith('en')) 
                                    || null;
                    voicesLoaded = true;
                    // Debugging/Logging
                    if (selectedVoice) {
                        console.log(`Voice loaded: ${selectedVoice.name}`);
                    } else {
                        console.warn("Could not find preferred voice. Using default or no voice.");
                    }
                };
                // Explicitly call getVoices to potentially trigger onvoiceschanged immediately 
                window.speechSynthesis.getVoices();
            }
            return selectedVoice;
        }

        function speakCallout(phrase) {
            if (config.voiceVolume === 0 || !('speechSynthesis' in window)) return;

            // CRUCIAL FIX: If voices haven't loaded, skip speaking this time.
            // The startTimer function ensures getVoice is called on the first user interaction.
            if (!voicesLoaded) {
                return;
            }

            const utterance = new SpeechSynthesisUtterance(phrase);
            utterance.volume = config.voiceVolume; 
            // Use the globally selected voice (set by getVoice)
            utterance.voice = selectedVoice || getVoice(config.voicePreference); 
            utterance.rate = 1.0; 

            // Prevent stacking multiple callouts
            if (!speechSynthesis.speaking) {
                window.speechSynthesis.speak(utterance);
            }
        }

        function playBeep(type) {
            // Set master volume for Tone.js
            if (Tone && Tone.Master) {
                Tone.Master.volume.value = -10; // Simple fixed volume
            }

            if (type === 'work') {
                workBeep.triggerAttackRelease('C4', '8n');
            } else if (type === 'rest') {
                restBeep.triggerAttackRelease('G3', '8n');
            } else if (type === 'final') {
                finalBeep.triggerAttackRelease('C5', '4n'); // Higher and longer for final warning
            } else if (type === 'end') {
                 // Double beep for phase end
                finalBeep.triggerAttackRelease('C4', '8n');
                setTimeout(() => finalBeep.triggerAttackRelease('C5', '8n'), 150);
            }
        }

        // --- Combo Generation Logic ---

        /**
         * Selects a random punch or move based on configuration settings.
         * Enforces rules for length and difficulty.
         */
        function selectRandomMove(currentCombo, lengthLimit, difficultyLevel, complexityLevel) {
            // 1. Determine available moves based on complexity
            let availableMoves = [...allPunches];
            if (complexityLevel > 0 && Math.random() < complexityLevel * 0.35) {
                // Incorporate non-punches more frequently as complexity increases
                availableMoves = availableMoves.concat(nonPunchMoves);
            }

            let nextMoveKey = null;
            let nextMove = null;
            let attempts = 0;
            const maxAttempts = 10;

            while (nextMoveKey === null && attempts < maxAttempts) {
                const randomIndex = Math.floor(Math.random() * availableMoves.length);
                const candidateKey = availableMoves[randomIndex];
                const candidateMove = punchMoves[candidateKey];

                // Ensure the candidate exists
                if (!candidateMove) {
                    attempts++;
                    continue;
                }
                
                // 2. Enforce Combo Length Limit: Prefer non-punch moves for the last spot if combo is long
                if (currentCombo.length >= lengthLimit - 1 && candidateMove.type === 'punch') {
                     // 50% chance to avoid a punch if we're at the limit-1 and it's not the last move
                    if (Math.random() < 0.5) {
                        attempts++;
                        continue;
                    }
                }
                
                // 3. Enforce Difficulty (Same-Side Rule)
                // Skip if current move side is the same as the last move side AND difficulty is Low (0)
                if (difficultyLevel === 0 && lastMoveSide === candidateMove.side) {
                    // For difficulty 0 (Strict), always reject consecutive same-side
                    attempts++;
                    continue; 
                }
                
                // If difficulty is Medium (1) or High (2), allow same-side based on chance
                // Medium (1) allows same-side 30% of the time (70% rejection)
                // High (2) allows same-side 70% of the time (30% rejection)
                if (lastMoveSide === candidateMove.side) {
                    const rejectionChance = (2 - difficultyLevel) * 0.35; // 0.7 for Medium, 0.35 for High
                    if (Math.random() < rejectionChance) {
                        attempts++;
                        continue;
                    }
                }

                // If all checks pass, accept the move
                nextMoveKey = candidateKey;
                nextMove = candidateMove;
            }

            // Fallback: if all attempts fail (very unlikely), just pick a 1 or 2
            if (nextMoveKey === null) {
                nextMoveKey = Math.random() > 0.5 ? '1' : '2';
                nextMove = punchMoves[nextMoveKey];
            }

            lastMoveSide = nextMove.side;
            return { key: nextMoveKey, call: nextMove.call };
        }

        /**
         * Generates a random boxing combo based on the current configuration.
         */
        function generateCombo() {
            const lengthMap = [2, 4, 6]; // Max combo length mapping for Low, Medium, High
            const lengthLimit = lengthMap[config.comboLength];
            const minLength = 1;
            const comboLength = Math.floor(Math.random() * (lengthLimit - minLength + 1)) + minLength;
            const repetitions = config.comboRepetitions;

            let comboKeys = [];
            let comboCallouts = [];
            lastMoveSide = null; // Reset side tracking for the start of a new combo

            for (let i = 0; i < comboLength; i++) {
                const move = selectRandomMove(comboKeys, comboLength, config.comboDifficulty, config.moveComplexity);
                comboKeys.push(move.key);
                comboCallouts.push(move.call);
            }

            const comboSpokenPhrase = comboCallouts.join(', ');
            
            // Repeat the spoken phrase based on intensity (repetitions)
            let repeatedSpoken = Array(repetitions).fill(comboSpokenPhrase).join('. ');
            
            // Total time is 1 second per move * number of repetitions (pace: 1 move/second)
            const totalComboTime = comboLength * repetitions; 
            
            // Combo Generation time (Config.comboTime) should be the *minimum* time for the combo.
            // Combo time is randomized, but respects the total spoken time.
            // Minimum interval between combos is the total spoken/execution time plus 1 second delay.
            const minComboTime = (totalComboTime + 1) * 1000;
            const maxComboTime = minComboTime + 3000; // Add up to 3 seconds of pause

            config.comboTime = Math.max(config.comboIntervalMin, Math.floor(Math.random() * (maxComboTime - minComboTime + 1)) + minComboTime);
            
            // Update UI
            config.comboCallout.innerHTML = `<span class="text-3xl sm:text-4xl text-white font-extrabold">${comboKeys.join(' - ')}</span>`;
            config.lastComboDisplay.textContent = `(${comboKeys.length} moves x ${repetitions} reps) -> ${repeatedSpoken}`;
            
            // Speak the callout
            speakCallout(repeatedSpoken);
            
            // Update the next callout time display
            updateComboCountdown(config.comboTime);

            return config.comboTime;
        }

        /**
         * Recursively generates combos until the round ends.
         */
        function comboLoop() {
            if (!config.timerRunning || config.currentPhase !== 'work') {
                return;
            }
            
            // Generate next combo and get the delay time
            const delayTime = generateCombo(); 

            // Set the timeout for the next combo generation
            comboInterval = setTimeout(comboLoop, delayTime);
        }
        
        /**
         * Updates the next combo timer UI
         */
        function updateComboCountdown(timeRemaining) {
            const countdownEl = document.getElementById('combo-countdown');
            
            // Clear any existing countdown interval to prevent stacking
            if (countdownEl.interval) {
                clearInterval(countdownEl.interval);
            }

            let remainingSeconds = Math.ceil(timeRemaining / 1000);
            countdownEl.textContent = `${remainingSeconds}s`;

            if (remainingSeconds > 0) {
                countdownEl.interval = setInterval(() => {
                    remainingSeconds--;
                    countdownEl.textContent = `${remainingSeconds}s`;
                    if (remainingSeconds <= 0) {
                        clearInterval(countdownEl.interval);
                        // countdownEl.textContent = '0s'; // Combo is generating, so it will be replaced immediately
                    }
                }, 1000);
            }
        }


        // --- Timer Core Logic ---

        function startRound(phase) {
            config.currentPhase = phase;
            config.timerRunning = true;
            
            // Set the initial time for the phase
            if (phase === 'work') {
                config.roundRemaining = config.roundDuration * 60;
                config.comboCallout.innerHTML = `<span class="text-slate-400 text-base">Get ready to work!</span>`;
                // Start the combo generation for the first time
                generateCombo();
                comboInterval = setTimeout(comboLoop, config.comboTime);
            } else if (phase === 'rest') {
                config.roundRemaining = config.restDuration * 60;
                config.comboCallout.innerHTML = `<span class="text-emerald-400">REST! Round ${config.currentRound + 1} next.</span>`;
                // Stop combo generation during rest
                clearTimeout(comboInterval);
            } else if (phase === 'finished') {
                endWorkout();
                return;
            }

            // Clear any previous warning timers
            clearTimeout(warningTimeout);
            
            // Set the timer interval
            timerInterval = setInterval(updateTimer, 1000);
            updateUI();
        }

        function updateTimer() {
            if (!config.timerRunning || config.roundRemaining <= 0) {
                handlePhaseEnd();
                return;
            }

            config.roundRemaining--;
            config.totalElapsed++;
            
            // Handle phase end warning sound and color change
            if (config.roundRemaining === 10) {
                playBeep('final');
                config.timerDisplay.style.color = 'var(--warn-color)';
                document.body.style.backgroundColor = 'var(--warn-color)';
            }
            if (config.roundRemaining < 10 && config.roundRemaining > 0) {
                warningTimeout = setTimeout(() => playBeep('final'), (10 - config.roundRemaining) * 1000);
            }

            updateUI();
        }

        function handlePhaseEnd() {
            clearInterval(timerInterval);
            clearTimeout(comboInterval);
            clearTimeout(warningTimeout);
            config.timerRunning = false;
            
            // Play a phase-end sound
            playBeep('end');
            
            if (config.currentPhase === 'work') {
                config.currentRound++;
                
                if (config.currentRound > config.numRounds) {
                    startRound('finished');
                } else {
                    // Only start rest if rest duration is > 0
                    if (config.restDuration > 0) {
                        startRound('rest');
                    } else {
                        // Skip rest and go straight to work
                        startRound('work');
                    }
                }
            } else if (config.currentPhase === 'rest') {
                startRound('work');
            }
        }

        function endWorkout() {
            config.currentPhase = 'finished';
            config.roundRemaining = 0;
            config.comboCallout.innerHTML = `<span class="text-green-400">WORKOUT COMPLETE!</span>`;
            
            // Display 00:00 on timer
            config.timerDisplay.textContent = formatTime(0);

            // Confetti animation!
            triggerConfetti();
            
            updateUI();
        }

        // --- User Control Functions ---

        function startTimer() {
            if (!config.timerRunning && config.roundRemaining > 0) {
                
                // FIX: Ensure voice is loaded on the first user interaction
                if (!voicesLoaded) {
                    getVoice(config.voicePreference);
                }
                
                // Ensure audio context is started on user interaction
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                }

                if (config.currentPhase === 'setup') {
                    // First time pressing start
                    startRound('work');
                } else {
                    // Resuming from pause
                    config.timerRunning = true;
                    // Restart combo loop if resuming in work phase
                    if (config.currentPhase === 'work') {
                        comboInterval = setTimeout(comboLoop, config.comboIntervalMin); // Start a new combo quickly
                    }
                    timerInterval = setInterval(updateTimer, 1000);
                }
                updateUI();
            }
        }

        function pauseTimer() {
            if (config.timerRunning) {
                config.timerRunning = false;
                clearInterval(timerInterval);
                clearTimeout(comboInterval);
                clearTimeout(warningTimeout);
                
                // Stop any speaking callouts
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                }

                config.comboCallout.innerHTML = `<span class="text-red-400">PAUSED</span>`;
                updateUI();
            }
        }

        function resetTimer() {
            pauseTimer();
            config.currentRound = 1;
            config.totalElapsed = 0;
            config.currentPhase = 'setup';
            config.roundRemaining = config.roundDuration * 60;
            config.timerDisplay.style.color = 'white';
            document.body.style.backgroundColor = 'var(--background-color)';
            config.comboCallout.innerHTML = `<span class="text-slate-400 text-base">Press Start to begin training!</span>`;
            config.lastComboDisplay.textContent = '--';
            updateUI();
        }

        // --- Fullscreen and Confetti ---

        function toggleFullscreen() {
            const doc = document.documentElement;
            const fullscreenIcon = document.getElementById('fullscreen-icon');

            if (!document.fullscreenElement) {
                if (doc.requestFullscreen) {
                    doc.requestFullscreen();
                } else if (doc.webkitRequestFullscreen) { /* Safari */
                    doc.webkitRequestFullscreen();
                } else if (doc.msRequestFullscreen) { /* IE11 */
                    doc.msRequestFullscreen();
                }
                fullscreenIcon.setAttribute('data-lucide', 'minimize');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
                fullscreenIcon.setAttribute('data-lucide', 'maximize');
            }
            lucide.createIcons();
        }
        
        function triggerConfetti() {
            const container = document.getElementById('confetti-container');
            const numPieces = 50;

            for (let i = 0; i < numPieces; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.left = `${Math.random() * 100}vw`;
                piece.style.top = `-${Math.random() * 20}vh`; // Start slightly off screen
                piece.style.backgroundColor = ['#f59e0b', '#fcd34d', '#ffffff'][Math.floor(Math.random() * 3)];
                piece.style.transform = `rotate(${Math.random() * 360}deg)`;
                piece.style.animationDelay = `${Math.random() * 0.5}s`;
                piece.style.animationDuration = `${2 + Math.random() * 1.5}s`; // Vary duration
                container.appendChild(piece);

                // Clean up the element after the animation
                piece.addEventListener('animationend', () => piece.remove());
            }
        }

        // --- Initialization ---

        window.onload = () => {
            // Initial configuration load and UI update
            updateConfig();
            updateVoiceVolume();

            // Set up event listeners for fullscreen toggling on specific keys
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F11' || (e.key === 'f' && document.activeElement.tagName !== 'INPUT')) {
                    e.preventDefault();
                    toggleFullscreen();
                }
            });
            
            // Re-render icons
            lucide.createIcons(); 
        };
    </script>
</body>
</html>
